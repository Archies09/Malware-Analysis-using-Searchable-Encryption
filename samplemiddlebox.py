import socket
import thread
from Cryptodome.Cipher import AES
from collections import OrderedDict
from multiprocessing import *
import multiprocessing
from subprocess import call
from tkinter import *
import os

#AES_128_GCM Encrypter
def Aes_128_gcm_encrypter(rule_token, key, nonce, aad):
#       key = binascii.hexlify(key)
#       plain_token = binascii.hexlify(plain_text)
#       nonce = binascii.hexlify(nonce)
#       aad = binascii.hexlify(aad)
        cipher_object = AES.new(key, AES.MODE_GCM,nonce)
        cipher_object.update(aad)
        cipher_token, verification_tag = cipher_object.encrypt_and_digest(rule_token)
        return cipher_token, verification_tag


def Tokenizer(rule, tokenization_type, token_length):
        tokenized_rule = []
        rule_length = len(rule)
        if tokenization_type == 1:
                for i in range(0,rule_length-token_length+1, token_length):
                        tokenized_rule.append(rule[i:i+token_length])
                if rule_length % token_length != 0:
                        tokenized_rule.append(rule[rule_length-token_length:])
        return tokenized_rule



def Socket_transmitter( socket0, socket1):
	while True:
        	try:
			request = socket0.recv(409600)
			socket1.sendall( request )
		except socket.error as err:
            		pass


def Token_connection(portno, return_val, token_traffic_queue):
	'''---------------------------------------------------Network connection with client--------------------------------'''


	middlebox_to_client_socket = socket.socket()
	middlebox_to_client_host = socket.gethostname()
	middlebox_to_client_port = portno
	middlebox_to_client_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
	middlebox_to_client_socket.bind((middlebox_to_client_host, middlebox_to_client_port))

	middlebox_to_client_socket.listen(10)
	print "Server is up and running..."
	#while True:
	client_to_middlebox_socket, client_address = middlebox_to_client_socket.accept()
	print "Connection from", client_address
	#print client_to_middlebox_socket.recv(32)

	'''---------------------------------------------------Collection and Tokenization of rules--------------------------------'''

	#For multi-token rule
	sample_rule = b"GET / HTTP/1.1\r\nHost: www.python.org"
#	sample_rule = b"bwh6tya45b7y5n7y4w6ys4e6nts46ys"
	another_sample_rule = b"fnratinethinuth5iunv4h3at4htintntih"
	number_of_rules = 2
	#Set by client
	block_size = 16
	tokenization_type = 1

	rule_list = []
	rule_list.append(sample_rule)
	rule_list.append(another_sample_rule)
	#rule_list.append("wertyuiopasdfghjklzxcv")
	i = 0
	tokenized_rule_list = [[] for temporary_iterator in range(len(rule_list))]
	for rule in rule_list:
	        tokenized_rule_list[i] = Tokenizer(rule, tokenization_type, block_size)
	        i = i + 1
	print "TOken list", tokenized_rule_list


	'''-------------------------------------------------Receiving Initial Salt---------------'''

	initial_salt = client_to_middlebox_socket.recv(block_size)
	#print initial_salt

	'''-------------------------------------------------Deterministically Encrypting Rules and make table------------------------------'''


	#Considering middlebox gets the key from somewhere
	#For AES GCM considering key size 128 i.e. 16 Bytes
	ssl_derived_key = b"1234567890abcdef"
	#12 Bytes
	sample_nonce = b"qazwsxedcrfv"
	#13 Bytes 
	sample_aad = b"qwertyuiopasd"

	# Making of table
	counter_table = OrderedDict()
	seed_key_table = OrderedDict()
	sequence_table = OrderedDict()
	match_table = OrderedDict()


	for i in range(number_of_rules):
	        prev_token = ""
	        first_flag = 1
	        for rule_token in tokenized_rule_list[i]:
	                encrypted_rule_token, verification_tag = Aes_128_gcm_encrypter(rule_token, ssl_derived_key, sample_nonce, sample_aad)
	                encrypted_rule_salt, verification_salt_tag = Aes_128_gcm_encrypter(str(hex(int(initial_salt, 16)).rstrip("L").lstrip("0x")), encrypted_rule_token.encode('hex'), sample_nonce, sample_aad)
	                counter_table[encrypted_rule_salt.encode('hex')] = 0
	                seed_key_table[encrypted_rule_salt.encode('hex')] = encrypted_rule_token.encode('hex')
	#Update sequence table and prev_token
	                if first_flag == 0:
	                        sequence_table[prev_token] = encrypted_rule_token.encode('hex')
	#Prefix matching not required if rule token is only one
	                if len(tokenized_rule_list[i]) == 1:
	                        match_table[encrypted_rule_token.encode('hex')] = -1
	#Default value previous token not matched
	                else:
	                        if encrypted_rule_token.encode('hex') not in match_table:
	                                match_table[encrypted_rule_token.encode('hex')] = 0

	                        if first_flag == 1:
	                                match_table[encrypted_rule_token.encode('hex')] = 2
	#                       print   match_table[encrypted_rule_token.encode('hex')]

	#Start of a rule
	                first_flag = 0
	                prev_token = encrypted_rule_token.encode('Hex')

	#print match_table
	#print prev_token
	copy_of_match_table = match_table.copy()
	copy_of_sequence_table = sequence_table.copy()

	#               print rule_token + "__________" + encrypted_rule_salt.encode('hex')
	#               if encrypted_rule_token.encode('hex') in counter_table:
	#                       counter_table[encrypted_rule_token.encode('hex')] = counter_table[encrypted_rule_token.encode('hex')] + 1
	#               else:
	#                       counter_table[encrypted_rule_token.encode('hex')] = 0

	#print counter_table


	'''-------------------------------------------------BlindBox Analysis of tokens-------------------------------------'''
	#Need to write logic for number of tokens
	malware_flag = 0
# 	return_val["Malware"] = "0"

	for i in range(63):
	        received_token = client_to_middlebox_socket.recv(block_size).encode('hex')
		token_traffic_queue.put(received_token)
	        if received_token in counter_table:
	#Single token rule match
	                if match_table[seed_key_table[received_token]] == -1:
	                        print "Malware found" + received_token
	                        malware_flag = 1
	#Starting of rule matched
	                if match_table[seed_key_table[received_token]] == 2 and seed_key_table[received_token] in sequence_table:
	                        match_table[sequence_table[seed_key_table[received_token]]] = 1
	#Multi token rule match
	                if seed_key_table[received_token] not in sequence_table:
	                        if match_table[seed_key_table[received_token]] == 1:
	                                print "Malware found" + received_token
	                                malware_flag = 1
	                else:
	                        if match_table[seed_key_table[received_token]] == 1:
	#prefix matched
	                                match_table[sequence_table[seed_key_table[received_token]]] = 1

	                temporary_counter = counter_table[received_token] + 1
	                seed_key = seed_key_table[received_token]
	                del counter_table[received_token]
	                del seed_key_table[received_token]
	                new_rule_token, verification_tag = Aes_128_gcm_encrypter(str(hex(int(initial_salt, 16)+temporary_counter).rstrip("L").lstrip("0x")), seed_key, sample_nonce, sample_aad)
	                counter_table[new_rule_token.encode('hex')] = temporary_counter
	                seed_key_table[new_rule_token.encode('hex')] = seed_key
	                if malware_flag == 1:
	                        match_table = copy_of_match_table.copy()
	#                       print new_rule_token.encode('hex')
	#                       print seed_key
#	                malware_flag = 0
	#               print match_table
#				return_val["Malware"] = "1"
                                if return_val.empty() == True :
                                        return_val.put("YES")
                                
	#print sequence_table
	#print match_table
	#print copy_of_match_table
	#print sequence_table
	'''-------------------------------------------------Closing connection with client--------------------------------'''
	

	client_to_middlebox_socket.close()



def Client_server_connection(client_to_middlebox_socket,traffic_queue, token_traffic_queue):
#	manager = multiprocessing.Manager()
#	return_val = manager.dict()
        return_val = multiprocessing.Queue()
	headers = client_to_middlebox_socket.recv(64)

	headers_list = headers.split(" ")

	server_host_and_port = headers_list[1].split(":")

	server = server_host_and_port[0]
	port = server_host_and_port[1]

	print "Server to forward", server, "Port to forward", port
	middlebox_to_server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

	# If we receive a CONNECT request
	if headers_list[0] == "CONNECT":
	    # Connect to port 443
	    try:
	        # If successful, send 200 code response
	        middlebox_to_server_socket.connect(( server, int(port) ))
	        reply = "HTTP/1.1 200 Connection established\r\n\r\n"
	#        reply += "Proxy-agent: Hi\r\n"
	#        reply += "\r\n"
	        client_to_middlebox_socket.sendall( reply.encode() )
	    except socket.error as err:
	        # If the connection could not be established, exit
	        # Should properly handle the exit with http error code here
		print(err)

	    token_process = Process(target=Token_connection, args=(44440, return_val, token_traffic_queue, ))
	    token_process.start()
	    token_process.join()
#	    print return_val.get()
#	    malware_found = return_val.get()
	    if return_val.empty() == True:
		    print "Starting to route traffic"
		    # Indiscriminately forward bytes
	            client_to_middlebox_socket.sendall("MALWARE NOT FOUND")
		    client_to_middlebox_socket.setblocking(0)
		    middlebox_to_server_socket.setblocking(0)
		    request = "a"
		    reply = "a"
		    traffic = ""
		    while True:
		    	try:
		            request = client_to_middlebox_socket.recv(8192)
		            middlebox_to_server_socket.sendall( request )
			    if request:
#				    event_text.insert("end", request)
		#		    print request
#				    traffic_text.insert(1,request)
				    traffic+=request
				    traffic_queue.put(request)
			    if request == "DONE":
			    	    break
		        except socket.error as err:
		            pass
		        try:
		            reply = middlebox_to_server_socket.recv(8192)
		            client_to_middlebox_socket.sendall( reply )
			    if reply:
 #   				    event_text.insert("end", reply)
				    traffic_queue.put(reply)
				    traffic+=reply
		        except socket.error as err:
		            pass
	    else :
                     malware_found = return_val.get()
                     if malware_found == "YES":
		        print "Malware found traffic blocked"
			traffic_queue.put("Malware Found Traffic BLOCKED")
			token_traffic_queue.put("Malware Found Traffic BLOCKED")
			client_to_middlebox_socket.sendall("MALWARE FOUND ERROR")
#			client_to_middlebox_socket.recv(1024)
                     else : print "UNKNOWN ERROR"
	'''
	try:
		thread.start_new_thread( Socket_transmitter, (client_to_middlebox_socket, middlebox_to_server_socket, ) )
		thread.start_new_thread( Socket_transmitter, (middlebox_to_server_socket, client_to_middlebox_socket, ) )
	except:
		print "Error: unable to start thread"
	while True:
		pass
	'''


	'''
	middlebox_to_server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
	middlebox_to_server_host = server
	middlebox_to_server_port = int(port)
	middlebox_to_server_socket.connect((middlebox_to_server_host, middlebox_to_server_port))
	client_to_middlebox_socket.send("CONNECTION")
	sample = client_to_middlebox_socket.recv(50)
	print sample
	middlebox_to_server_socket.sendall(sample)
	print "Sending Done"
	client_to_middlebox_socket.send(middlebox_to_server_socket.recv(50))
	print "Receiving Done"
	'''
	client_to_middlebox_socket.close()
	middlebox_to_server_socket.close()

def Middlebox_begin(traffic_queue,token_traffic_queue):
	middlebox_to_client_socket = socket.socket()
	middlebox_to_client_host = "127.0.0.1"
	#socket.gethostname()
	middlebox_to_client_port = 44448
	middlebox_to_client_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
	middlebox_to_client_socket.bind((middlebox_to_client_host, middlebox_to_client_port))
	middlebox_to_client_socket.listen(20)
#	client_pool = Pool(Processes=4)
	print "Middlebox begins & Server is up and running..."
	while True:
#		if traffic_queue.empty() == False:
#		if traffic_queue.get_nowait() == "STOP MIDDLEBOX":
#			break
		client_to_middlebox_socket, client_address = middlebox_to_client_socket.accept()
		print "Connection from", client_address
		client_process = Process(target=Client_server_connection, args=(client_to_middlebox_socket,traffic_queue,token_traffic_queue,))
		client_process.start()
	middlebox_to_client_socket.close()

def Load_ui():
	window = Tk() 
	window.title("Middlebox Window")
	window.geometry("1820x1080")
	label = Label(window, text="Please Press The Button:")
	label.grid(column=0,row=0)
	traffic_queue = multiprocessing.Queue()
	token_traffic_queue = multiprocessing.Queue()
	
	def stop_click():
		#traffic_queue.put("STOP MIDDLEBOX")
#		print "ABOUT TO SYS EXIT"
		window.destroy()
		call(["killall","python"])
#		sys.exit()
#		os.system('kill %d' % os.getpid())

	def clicked():
		label.configure(text = "Middlebox begins")
		middlebox_start = Process(target=Middlebox_begin, args=(traffic_queue, token_traffic_queue))
		middlebox_start.start()
	def show_traffic():
#		print traffic_queue.get()
		while traffic_queue.empty()==False:
			event_text.insert(END,unicode(traffic_queue.get(), errors='replace'))
#		print "LOOP ENDSSSS"
		while token_traffic_queue.empty()==False:
			token_traffic_text.insert(END,unicode(token_traffic_queue.get()+"\n", errors='replace'))
		ybar.config(command=event_text.yview)
		event_text.config(yscrollcommand=ybar.set)
		event_text.update_idletasks()
#		print "TRAFFIC DONE"
	show_traffic_btn = Button(window,text="Show Traffic", command=show_traffic)
	switch_btn = Button(window, text="Start", command=clicked)
	stop_btn = Button(window, text="Stop", command=stop_click)
	switch_btn.grid(column=5, row=1)
	stop_btn.grid(column=50, row=1)
	show_traffic_btn.grid(column=10, row=2)
#	traffic_text.grid(column=1, row=15)
	event_text=Text(window, height=50, width=100)
	event_text.grid(row=2, column=2)
	token_traffic_text=Text(window, height=50, width=50)
	token_traffic_text.grid(row=2, column=4)
	ybar= Scrollbar(window)
	ybar.grid(row=2, column=3)
	window.mainloop()

if __name__ == '__main__':
	user_interface = Process(target=Load_ui)
	user_interface.start()
