import binascii
from base64 import b64decode
from Cryptodome.Cipher import AES
from collections import OrderedDict
import time
import select
from OpenSSL import SSL
import socket
from multiprocessing import *
import multiprocessing
from tkinter import *
import os
from subprocess import call

#AES_128_GCM Encrypter
def Aes_128_gcm_encrypter(plain_token, key, nonce, aad):
#       key = binascii.hexlify(key)
#       plain_token = binascii.hexlify(plain_text)
#       nonce = binascii.hexlify(nonce)
#       aad = binascii.hexlify(aad)
        cipher_object = AES.new(key, AES.MODE_GCM,nonce)
        cipher_object.update(aad)
        cipher_token, verification_tag = cipher_object.encrypt_and_digest(plain_token)
        return cipher_token, verification_tag


#Tokenization type is 0=delimiter based tokenization 1=regular tokenization
def Tokenizer(plaintext, tokenization_type, token_length, token_traffic_queue):
        token_list = []
        plaintext_length = len(plaintext)
        if tokenization_type == 1:
                for i in range(0,plaintext_length-token_length+1):
                        token_list.append(plaintext[i:i+token_length])
			token_traffic_queue.put(plaintext[i:i+token_length])

        return token_list


def verify_cb(conn, cert, errun, depth, ok):
        return True

def Token_connection(portno, url, token_traffic_queue):
	'''---------------------------------------Network connection with middlebox-------------------------------------'''


	client_to_middlebox_socket = socket.socket()
	client_to_middlebox_hostname = socket.gethostname()
	client_to_middlebox_port = portno

	if client_to_middlebox_socket.connect_ex((client_to_middlebox_hostname, client_to_middlebox_port))!=0:
		print "SOCKET ERROR"
#		os.system('kill %d' % os.getpid())
		call(["killall","python"])
		sys.exit()
	#print client_to_middlebox_socket.send("12345678912345678900123456789012")


	'''---------------------------------------Collection and Tokenization of plaintext------------------------------'''


	#Taking Plaintext from pcap, Later to be replaced by live traffic. Currently, pcap only has malware in it's plaintext. Hence it will work for demo but need to test on live traffic
	#plaintext = raw_input("Enter a Test String")
	#For AES GCM block size is 128 bits i.e. 16 Bytes i.e 16 ASCII characters
#	plaintext = b"GET / HTTP/1.1\r\nHost: www.python.org\r\nConnection: close\r\n\r\n"
	plaintext = b"GET / HTTP/1.1\r\nHost: " + url + b"\r\nConnection: close\r\n\r\n"
	block_size = 16
	#0=Delimiter based tokens 1=Regular Tokens
	type_of_tokenization = 1
	token_list = Tokenizer(plaintext, type_of_tokenization, block_size, token_traffic_queue)
	#print "LeNgTh", len(token_list)
#	token_traffic_queue.put(''.join(str(x) for x in token_list))
	print token_list

	'''---------------------------------------Sending Initial Salt and encrypted tokens-----------------------------'''


	initial_salt = b"1234567890abcdef"
	client_to_middlebox_socket.send(initial_salt)
	#numeric_initial_salt = initial_salt.encode('hex')
	#print numeric_initial_salt
	#for token in counter_table:
	#       print str(hex(int(initial_salt, 16)+counter_table[token]).rstrip("L").lstrip("0x"))
	#       print token

	'''---------------------------------------Deterministically Encrypting Tokens-----------------------------------'''
	#For AES GCM considering key size 128 i.e. 16 Bytes
	ssl_derived_key = b"1234567890abcdef"
	#12 Bytes
	sample_nonce = b"qazwsxedcrfv"
	#13 Bytes 
	sample_aad = b"qwertyuiopasd"

	counter_table = OrderedDict()
	for plain_token in token_list:
	#       print plain_token
	#       print ssl_derived_key
	#16Bytes input in characters 16Bytes key in characters 16 Bytes output in characters i.e. 32 Bytes of hex output
	        encrypted_token, verification_tag = Aes_128_gcm_encrypter(plain_token, ssl_derived_key, sample_nonce, sample_aad)
	        if encrypted_token.encode('hex') in counter_table:
	                counter_table[encrypted_token.encode('hex')] = counter_table[encrypted_token.encode('hex')] + 1
	        else:
	                counter_table[encrypted_token.encode('hex')] = 0
	#       print plain_token
	        #print encrypted_token.encode('hex')
	        #print "WWWWW" + binascii.hexlify(encrypted_token)

	#16Bytes input in characters 16Bytes key in characters 16 Bytes output in characters i.e. 32 Bytes of hex output
	        encrypted_salt, verification_tag = Aes_128_gcm_encrypter(str(hex(int(initial_salt, 16)+counter_table[encrypted_token.encode('hex')]).rstrip("L").lstrip("0x")), encrypted_token.encode('hex'), sample_nonce, sample_aad)
	        client_to_middlebox_socket.send(encrypted_salt)
	        print encrypted_salt.encode('hex')


	#print counter_table


	'''---------------------------------------End connection with middlebox-----------------------------------------'''


	client_to_middlebox_socket.close

def client_begin(web_url, proxy_address, proxy_port, traffic_queue, time_queue, token_traffic_queue):
	start_time = time.time()
#	server = 'www.python.org'
	server = web_url.encode('utf-8')
	server = server[:len(server)-1]
	print type(server)
	print server
	print type(web_url)

#	print server
	port = 443
	#PROXY_ADDR = ("133.18.198.76", 3128)
#	PROXY_ADDR = ("127.0.0.1", 44448)
#	PROXY_ADDR = ("36.37.124.235", 36179)
	PROXY_ADDR = (proxy_address, int(proxy_port))
	CONNECT = "CONNECT %s:%s HTTP/1.1\r\nConnection: close\r\n\r\n" % (server, port)
	print CONNECT.encode('hex')
	s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
	print("STOPPED1")
	if s.connect_ex(PROXY_ADDR)!=0:
		print "Connection Not Found"
		token_traffic_queue.put("Connection Error. Please Start Again.")
		traffic_queue.put("Connection Error. Please Start Again.")
	else:

	#		os.system('kill %d' % os.getpid())
		print("STOPPED2")
		s.send(CONNECT)
		print s.recv(4096)      

		'''
		ctx = SSL.Context(SSL.TLSv1_2_METHOD)
		ss = SSL.Connection(ctx, s)

		# Go to client mode
		ss.set_connect_state()
		# start using HTTP
		temp = b"HEAD /HTTP/1.0\r\nHost:www.python.org\r\n\r\n"
		print temp.encode('hex')
		print len(temp)
		ss.sendall(b"HEAD /HTTP/1.0\r\nHost:www.python.org\r\n\r\n")
		#print "Sever response:"
		#print "-" * 40
		while 1:
			try:
				buff = ss.recv(4096)
			except 	SSL.ZeroReturnError:
			            # we're done
				break

		print buff,
		'''
		token_process = Process(target=Token_connection, args=(44440,server,token_traffic_queue,))
		token_process.start()

	#	ss.setblocking(0)
		if s.recv(1024) == "MALWARE FOUND ERROR":
			traffic_queue.put("MALWARE FOUND ERROR")
			print "WORKING FINE"
			s.close()
			end_time = time.time()
			print "Time:", end_time-start_time
			time_queue.put(end_time-start_time)

		else :
	#		ss.setblocking(1)
			ctx = SSL.Context(SSL.TLSv1_2_METHOD)
			ctx.set_verify(SSL.VERIFY_PEER, verify_cb)
			ss = SSL.Connection(ctx, s)

			ss.set_connect_state()
			ss.do_handshake()
			cert = ss.get_peer_certificate()
			print cert.get_subject()
			print ss.get_cipher_name()
			#print ss.sendall(b"HEAD /HTTP/1.1\r\nHost: www.python.org\r\n\r\n")

			#print ss.recv(1024).split(b"\r\n")

			#print ss.sendall(b"GET / HTTP/1.1\r\nHost: www.python.org\r\n\r\n")

			print ss.sendall(b"GET / HTTP/1.1\r\nHost: " + server + b"\r\nConnection: close\r\n\r\n")
			print b"GET / HTTP/1.1\r\nHost: " + server + b"\r\nConnection: close\r\n\r\n"


			#ss.setblocking(0)
			#time.sleep(1)
			buff=""
			while 1:
			        try:
					print "here"
					reader_list, writer_list, exception_list = select.select([ss],[],[],0.5)
					if ss in reader_list:
						buff += ss.recv(1024)
					else:
						 print "break"
					 	 break
		#			print buff
		#			traffic_queue.put(buff)
		#			print "NotInHere"
				except  SSL.Error:
			               	break
					# we're done
			#print buff,
			traffic_queue.put(buff)
			s.send("DONE")

			ss.shutdown()
			ss.close()
			s.close()
	end_time = time.time()
	print "Time:", end_time-start_time
	time_queue.put(end_time-start_time)

def Client_url():
	window = Tk()
        window.title("Client Window")
        window.geometry("1820x1080")
        label = Label(window, text="Please Press The Button after entering url:")
        label.grid(column=0,row=0)
	event_text=Text(window, height=1, width=100)
	address_text=Text(window, height=1, width=30)
	port_text=Text(window, height=1, width=10)
	event_text.grid(column=1, row=2)
	address_text.grid(column=1, row=3)
	port_text.grid(column=2, row=3)
	traffic_queue = multiprocessing.Queue()
	time_queue = multiprocessing.Queue()
	token_traffic_queue = multiprocessing.Queue()
	def clicked():
		web_url = event_text.get('1.0',END)
		web_addr = address_text.get('1.0',END)
		web_port = port_text.get('1.0',END)
		print "THIS IS EXTRACTED URL"
		print web_url
		client_process = Process(target=client_begin, args=(web_url, web_addr, web_port, traffic_queue,time_queue,token_traffic_queue,))
        	client_process.start()
#		client_process.join()
		token_text = Text(window, height=30, width=80)
		response_text = Text(window, height=30, width=80)
		response_text.grid(column=1, row=4)
		token_text.grid(column=2, row=4)
		while token_traffic_queue.empty() == True:
			pass
		print "LOOOP"
		while token_traffic_queue.empty() == False:
			token_text.insert(END, "---------------------")
			token_text.insert(END, "\n"+token_traffic_queue.get()+"\n")
			token_text.insert(END, "---------------------")

		while traffic_queue.empty() == True:
			pass
		response_text.insert(END,unicode(traffic_queue.get(), errors='replace'))

		time_text=Text(window, height=1, width=50)
	        label = Label(window, text="Time")
	        label.grid(column=1,row=5)
		time_text.grid(column=2, row=5)
		while time_queue.empty() == True:
			pass
		time_text.insert(END,unicode(str(time_queue.get()), errors='replace'))
	def closeclick():
		window.destroy()
		os.system('kill %d' % os.getpid())
	url_btn = Button(window, text="URL", command=clicked)
        url_btn.grid(column=2, row=2)
	close_btn=Button(window, text="Close", command=closeclick)
	close_btn.grid(column=3, row=2)

	window.mainloop()

if __name__ == '__main__':
	client_ui = Process(target=Client_url)
        client_ui.start()
